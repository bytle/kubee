#!/bin/bash

# Not finished
# Was started to verify a JWS signed by Dex
#
# thinking that dex was signing with the ca private key
# but it does not

# The key are generated by dex and are available in the https://dex.hostname/keys
# end point

# shellcheck source=./bashlib-doc.sh
source "bashlib-doc.sh"

synopsis(){

  echo "Usage:"
  echo ''
  echo 'Jwt command'
  echo ''
  echo '```bash'
  # shellcheck disable=SC2005
  echo "kubee jwt command JwtToken"
  echo '```'
  echo "where: command may be:"
  # shellcheck disable=SC2016
  # shellcheck disable=SC2016
  echo '  * `print` : Print the Jwt in text format'


}



HELP=${1:-}
if [[ $HELP == "synopsis" ]]; then
  doc::help synopsis
  exit
fi

if [[ $HELP =~ -h|--help|help ]]; then
  doc::help synopsis
  exit
fi


# Function to decode JWT parts
decode_base64_url() {
    local len=$((${#1} % 4))
    local result="$1"
    if [ $len -eq 2 ]; then result="$1"'=='
    elif [ $len -eq 3 ]; then result="$1"'='
    fi
    echo "$result" | tr '_-' '/+' | base64 -d
}

# Function to base64url encode
base64url_encode() {
    echo -n "$1" | base64 | tr '+/' '-_' | tr -d '='
}

function print_jwt(){

    local JWT_BASE64_URL="$1"



    # Split JWT into parts
    IFS='.' read -r HEADER_BASE_64 ENCODED_PAYLOAD ENCODED_SIGNATURE <<< "$JWT_BASE_64"

    if [ -z "$HEADER_BASE_64" ] || [ -z "$HEADER_BASE_64" ] || [ -z "$ENCODED_SIGNATURE" ]; then
        echo "Error: Invalid JWT format"
        exit 1
    fi

    # Extract the header
    # Header  = {
    #  "alg": "RS256",
    #  "kid": "5c6097630863e16d9eb72adf2c6f4624aeb1f6aa"
    #}
    #echo "Encoded Header: $HEADER_BASE_64"
    echo "Data Header:"
    JSON_HEADER=$(decode_base64_url "$HEADER_BASE_64" 2>/dev/null)
    echo "$JSON_HEADER" | jq -r .

    # Extract the payload
    #echo "Encoded Payload: $ENCODED_PAYLOAD"
    echo "Data Payload:"
    JSON_PAYLOAD=$(decode_base64_url "$ENCODED_PAYLOAD" 2>/dev/null)
    echo "$JSON_PAYLOAD" | jq -r .


    # Extract the signature
    # The third and last part of JWT
    echo "$ENCODED_SIGNATURE"
    #| tr '_-' '/+' | base64 -d 2>/dev/null

}

sign(){
  # Create JWT header
  HEADER='{
      "alg": "RS256",
      "typ": "JWT"
  }'

  # Encode header and payload
  HEADER_BASE_64=$(base64url_encode "$HEADER")
  ENCODED_PAYLOAD=$(base64url_encode "$(cat "$PAYLOAD_FILE")")

  # Create signing input
  SIGNING_INPUT="${HEADER_BASE_64}.${ENCODED_PAYLOAD}"

  # Create signature
  SIGNATURE=$(echo -n "$SIGNING_INPUT" | openssl dgst -sha256 -sign "$PRIVATE_KEY" | base64 -w 0 | tr '+/' '-_' | tr -d '=')
}


function verify_jwt(){

  local secret="$1"
  local JWT="$2"

  # Split JWT into parts
  IFS='.' read -r HEADER_BASE_64 ENCODED_PAYLOAD ENCODED_SIGNATURE <<< "$JWT"

  JSON_HEADER=$(decode_base64_url "$HEADER_BASE_64" 2>/dev/null)
  JSON_PAYLOAD=$(decode_base64_url "$ENCODED_PAYLOAD" 2>/dev/null)
  # Create signing input
  SIGNING_INPUT="${JSON_HEADER}.${JSON_PAYLOAD}"

  # Decode signature
  DECODED_SIGNATURE=$(decode_base64_url "$ENCODED_SIGNATURE")

  # Get the public key from the CA cert
  # pubkey.pem
  PUB_KEY=$(openssl x509 -pubkey -noout)

  # Verify the signature
  #echo -n "$(echo "$JWT" | cut -d "." -f1,2 | tr -d '\n' | base64 -d 2>/dev/null)" | \
  #    openssl dgst -sha256 -verify pubkey.pem -signature <(echo -n "$SIGNATURE")


  # Verify signature
  echo -n "$SIGNING_INPUT" | \
    openssl dgst -sha256 \
      -verify <(echo "$PUB_KEY") \
      -signature <(echo -n "$DECODED_SIGNATURE" | base64 -d) \
      2>/dev/null

  if [ $? -eq 0 ]; then
      echo -e "\nSignature verification: SUCCESS"
      exit 0
  else
      echo -e "\nSignature verification: FAILED"
      exit 1
  fi

}

COMMAND=${1:-}
if [ "$COMMAND" == "" ]; then
    doc::help synopsis
    echo::err "A command is mandatory"
    exit 1
fi
shift


case "$COMMAND" in
  "verify")
    verify_jwt "$@"
  ;;
  "print")
    print_jwt "$@"
  ;;
  *)
    doc::help synopsis
    echo::err "command $COMMAND not found"
    exit 1
esac
